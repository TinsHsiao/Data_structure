任務一 :
謝爾排序
最外部利用for迴圈將gap設定為資料的大小的一半，每做完迴圈的一次就再除2。
第二個迴圈則是設定i為gap的值往後加一直到跑完所有資料，gap以後的每筆資料都往後加一去做內部迴圈的檢查與交換。
最內部的迴圈是目前位置的資料也就是location項去跟location減gap位置的資料去兩個兩個比較，如果目前位置的Arrival比較小，就要去交換兩筆資料，使小的資料往前放；如果兩筆資料的Arrival相等，就要看OID，目前項的OID比較小時就要交換兩筆資料。
迴圈結束前將location設定為location減gap，直到大於或是跑到第gap項的位置才會停止。


任務二、任務三 :
  建立一個CPU的class裡面要有處理各種工作情況
(1.清空佇列、2.下筆工作抵達時間 >= 目前cpu工作結束時間、3.成功執行完成目前的工作 )
的處理方式，也要記錄cpu工作執行結束的時間。

在模擬cpu執行情況的時，根據需要的cpu數量去宣告一個vector<CPU>，要記錄最快結束工作的cpu的時間，還要記錄哪個編號的cpu裡等待工作最少。

每一筆工作要進來的時候，先去檢查這個工作的抵達時間是否 >= 目前最快結束工作的cpu時間，
如果是就去檢查每一個cpu的佇列，根據佇列裡的工作取出時間判斷他是否完成或取消，一直檢查到此cpu的時間 > 這個工作的抵達時間，或佇列為空。
檢查完目前各cpu裡的工作進程之後，重新設定最少等待工作的cpu編號，如果這個編號的cpu是閒置的，就把此工作丟給他執行並把此工作放進完成清單裡，不然的話就讓他進此cpu的佇列裡等待。

如果抵達時間 < 目前最快結束工作的cpu時間且每個cpu的佇列都滿了，就讓他進取消清單。

如果都不是上面兩種情況的話就去檢查現在等待人數最少的cpu是否為閒置情況，如果是就把這個工作丟給等待人數最少的cpu執行，並把它丟到完成清單中；如果不是就讓它進這個cpu的佇列裡等待。

每筆資料檢查完之後，都要去更新最快結束的時間和最少等待工作的cpu編號，一直到把所有的工作都處理好。

工作都處理好之後，就去把每一個cpu佇列清空，根據佇列裡的工作取出的時間判斷他是否完成或取消。

任務二和任務三的差別在於設定不同的cpu數量任務二設為1、任務三設為2。

任務一的流程圖

任務二的流程圖


心得 :

蕭合亭 
這次作業讓我學到最多的是如何去實踐封裝的應用，一開始完全不懂是在做什麼，看了很多次題目後才慢慢理解，我覺得要把架構寫好很難，寫出的第一個版本，因為沒把架構想好，雖然可以順利讀檔寫檔，但程式碼很雜亂，跟組員討論後才知道怎麼寫會比較清楚簡潔，上機的任務比較複雜，多了一個cpu要考慮的東西多了很多，花了很多時間才弄懂，組員教我很久，最後順利交出檔案，覺得自己學到了很多技巧。

連翊安
在寫完任務一和任務二之後，發現應該要讓cpu是一個獨立的class，讓各cpu去管理自己佇列裡的東西、工作狀態，在模擬的時候宣告vector<CPU> 之後，各cpu的狀態就是獨立的而且也符合各cpu配置一條佇列，之後只要讓各cpu更新狀態和更新目前最少等待工作的cpu編號就可以了，這次作業的難點在於，要先搞清楚整個模擬的運行模式，一開始很難理解為甚麼是那樣的結果，後來把他想成櫃台服務，很快就通了。




























任務一 :
謝爾排序
最外部利用for迴圈將gap設定為資料的大小的一半
每做完迴圈的一次就再除2

第二個迴圈則是設定i為gap的值往後加一直到跑完所有資料
gap以後的每筆資料都往後加一去做內部迴圈的檢查與交換

最內部的迴圈是目前位置的資料也就是location項去跟減gap位置的資料去兩個兩個比較
如果是目前位置的Arrival比較小 就要去交換兩筆資料 使小的資料往前放
如果是兩筆資料的Arrival相等 就要看OID 目前項的OID比較小時就要交換兩筆資料
迴圈結束前會將location設定為location減gap
直到大於或是跑到第gap項的位置才會停止 


任務二、任務三 :
  建立一個CPU的class裡面要有處理各種工作情況
(1.清空佇列、2.下筆工作抵達時間 > 目前cpu工作結束時間、3.成功執行完成目前的工作 )
的處理方式，也要記錄cpu工作執行結束的時間

在模擬cpu執行情況的時候 要記錄最快結束工作的cpu的時間
還要記錄哪個編號的cpu裡等待工作最少 


每一筆工作要進來的時候 先去檢查這個工作的抵達時間是否 >= 目前最快結束工作的cpu時間 
如果是小於 就去檢查每一個cpu的佇列 根據佇列裡的工作取出時間判斷他是否完成或取消 一直檢查到 此cpu的時間 > 這個工作的抵達時間 或佇列為空
檢查完目前個cpu裡的工作進程之後 重新設定最少等待工作的cpu編號 如果這個編號的cpu是閒置的 就把此工作丟給他執行並把此工作放進完成清單裡 不然的話就讓他進此cpu的佇列裡等待

如果抵達時間 < 目前最快結束工作的cpu時間 且 每個cpu的佇列都滿了 就讓他進取消清單

如果都不是上面兩種情況的話就去檢查現在等待人數最少的cpu是否為閒置情況 如果是就把這個工作丟給等待人數最少的cpu執行 並把他丟到完成清單中
如果不是就讓他進這個cpu的佇列裡等待

每筆資料檢查完之後 都要去更新最快結束的時間 和 最少等待工作的cpu編號
一直到把所有的工作都處理好


工作都處理好之後 就去把每一個cpu佇列清空，根據佇列裡的工作取出的時間判斷他是否完成或取消

任務二和任務三的差別在於 設定不同的cpu數量 任務二設為1 任務三設為2

\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

選擇排序法:
把未排序好的數字中的最小值與未排序好的數字最左邊的值交換，並將它標示為已排序。

不穩定:
如果有兩個一樣內容的值，排序後相對位置交換則為不穩定。