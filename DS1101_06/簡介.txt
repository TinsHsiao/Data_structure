任務一 :
在Add函式裡使用遞迴去新增節點與資料
當目前資料的生命值比下一筆要進來的資料的生命值大時，就會呼叫自身函式傳入目前節點的左邊指向，使資料放到此節點的左邊再利用遞迴去找下一個方向，直到目前的節點無下一個節點時(base case)，就將資料放入；當目前資料的生命值小於等於下一筆資料的生命值，就呼叫自身函式傳入目前節點的右邊指向，使資料放置到目前節點的右邊再遞迴去找下一個方向，直到無下一節點(base case)就會將資料放進。

Height函式傳入根去找樹高
當head指向NULL時，觸底反彈(base case)，宣告且設定right為呼叫遞迴，傳入參數為head的右指向，找出目前節點的右指向的樹高大小；宣告且設定left為呼叫遞迴，傳入參數為head的左指向，找出目前節點左指向的樹高大小。當right大於left時，回傳right的值加1(1此節點)；當right小於等於left時，回傳left加1(1此節點)。透過不斷的遞迴呼叫，留下大較深分支的數值，從下層往上觸底回傳，最終可以找到樹高。

getBoder函數找二元樹最左、最右的資料索引
當tree為NULL時，回傳pre(tree的前一個)的索引，如果是要找最左邊的資料，就呼叫產生遞迴，傳入目前項的左邊、目前項，前項是為了往左找、後項是為了在base case的時候回傳上一指向的節點的index。右邊也是使用此方法，依此類推。

任務二: 
  建立最大堆積，從最底層的父節點開始檢查，先看此節點的子節點HP值，看哪個比較大，如果都一樣就選左邊，之後再去看HP值較大的子節點有沒有比父節點大，有的話再把他們交換，交換之後再將父節點設定為被交換的子節點在重複檢查看原本整理好的最大堆積有沒有被破壞掉，一直檢查到父節點 > ( size - 1 ) / 2或者是不能再交換了，就完成最大堆積。

任務三:
先將根(index = 0)印出；再呼叫DeleteRoot，將根與最後一項交換，交換後刪除最後一項(原為根)，重新設定size的大小，再利用函式Heapify把目前的根去做排序交換，以完成堆積；利用堆積的樹高運算方式分別將高log2(資料的大小)、最左節點資料(2的樹高減一次方再減一)、最下節點資料印出(最後一筆資料)。

心得:
我們這次的作業寫得很順手，思緒也很清晰，任務一就像是上次作業的概念去寫，很快就寫完了；任務二在看完老師的影片、查資料後，很快地有了想法，透過數據比對去增加條件，使程式達成要求；這次挑戰題相較以往比較簡單，用了簡短有力的方式寫出來，也去新增了一些任務二的條件，讓程式碼更加完善。不僅了解了堆積的概念，也對遞迴去完成二元搜尋樹更加熟練。
